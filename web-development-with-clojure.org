#+TITLE:
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{fullpage}
# #+LATEX_HEADER: \usepackage{indentfirst}
#+OPTIONS: toc:nil
#+BIND: org-export-latex-title-command ""
#+LATEX: \setcounter{secnumdepth}{-1}
#+LATEX: \setlength{\parindent}{0in}
#+LATEX: \addtolength{\parskip}{\baselineskip}

* Abstract
Web development currently consists of several distinct technologies;
often server-side code is written in C# or Java while the client-side
code is written in JavaScript. Clojure is a new language that can unify
client-side and server-side. A dialect of Lisp, Clojure compiles both to
Java bytecode, for the server-side, and to JavaScript, for the
client-side. Clojure can thus leverage all the power of the existing
Java and JavaScript libraries, while adding its own libraries for a
uniform functional programming paradigm. This as well as lazy evaluation
provides for easier use of concurrency. Clojure also provides a
live-coding experience, where running processess can be modified
on-the-fly to match changes being made to the code.

This article will focus on how using Clojure for web development will impact the software development process.
No preference will be given to a specific model, although, as will be demonstrated, Clojure holds the most
benefit for a methodology centered on iteration such as Agile.

* Clojure
** What is Clojure
Clojure is a general-purpose programming langauge that is a dialect of Lisp.
The main differentiating aspect of Clojure from other Lisps is that it compiles to Java bytecode,
and can therefore run on any Java Virtual Machine (JVM).
It can also be compiled to JavaScript as well as to bytecode targeting the CLR (the .NET runtime engine).
This feature alone makes Clojure quite portable as the JVM and JavaScript are widely available platforms.

Clojure is a dynamically typed language that, though compiled, is highly interactive.
According to the language webpage, "Every feature supported by Clojure is supported at runtime." \cite{Clojure:2014}

The ability to compile the same Clojure code to Java bytecode and JavaScript makes an integrated codebase via
code sharing between client-side and server-side code sharing possible. One example is that of input validation;
for security purposes validation must be performed on the server side; though it is also beneficial to validate on the
client side in order to provide improve latency and to diminish calls to the server.
In the past, validation code was written in both Java and JavaScript, and the validation logic needed to be kept synced between
the two implementations. Now, Clojure makes it possible to satisfy DRY (Don't Repeat Yourself) principles while ensuring a uniform
input validation.

** Notable Features of Clojure
*** Interactivity via the REPL
Perhaps the most salient feature of Clojure as well as the one having the most impact upon the software engineering process
is the highly interactive nature of Clojure programming via the Read-Eval-Print-Loop (REPL).
In many traditional programming langauges like C, COBOL, or Java, it is necessary to compile the program in its entirety before
running the executable process for testing purposes.
Any change to the source code necessitates recompiling the affected objects and restarting the process.

With Clojure, the process being executed can be modified on the fly, drastically reducing time between testing iterations.
A programmer and graphic designer by the name of Bret Victor touted the benefits of instantaneous feedback in his 2012 CUSEC talk
called "Inventing on Principle"\cite{Victor}.
One of his main ideas was an code editor with which one could modify a video-game one was programming in real-time.
Shortly after Victor gave his speech, another programmer by the name of Chris Granger implemented the idea using Clojure,
which serves to show the power of Clojure with regards to run-time modification.

For teams using Agile methodology, this ability is highly relevant; if large iterations are valued,
why not achieve more small iterations?

Like many other Lisps, Clojure has good integration with Emacs.
Using a library called cider, code can be typed and evaluated inside of an Emacs buffer,
then automatically executed on another thread running the Clojure code.
This setup turns the task of changing a method in a program from one that requires a re-compile and a
restart on the child process to one that only requires a keystroke to see the new code running.

*** Higher-Order Functions and Functional Programming

*** Concurrency

*** Lazy Evaluation

*** Cheap Data-Structures
One notable feature of Clojure over other Lisps is the native implementation of several
diverse and sundry data-structures such as lists, vectors, sets, and maps.
All of these data-structures are immutable and can be declared in the code very concisely.
Thus they are "cheap" in the typographical sense.
Any programmer who has had to work with the Standard Template Library (STL) of C++ will be sure to appreciate these.

TODO: code example

*** Macros

*** Library and Dependency Management
While Clojure does not technically come with a build tool, the /de
facto/ standard among Clojure developers is the excellent Leiningen
tool.  Leiningen can either be installed via a package manager or by
downloading the =lein= script from the project page. \cite{lein}

Leiningen acts as a package manager for a Clojure project by
automatically handling dependencies and compilation.

Assuming =lein= is installed the machine, running =lein new
my-project= at the command prompt
will generate a directory structure for a new Clojure project named
=my-project=. Note that there is also a templating system for generation
of projects; that is outside the scope of this document.

Running =lein repl= inside a project directory will start up a REPL
session.

Leiningen really shines when it comes to using Clojure libraries.  Each
project directory structure created by Leiningen has a =project.clj=
file which is a Clojure file that uses the =defproject= macro to
define a project. See the following sample =project.clj= file:

#+begin_src clojure
(defproject couchdb-from-clojure "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.5.1"]
                 [com.ashafa/clutch "0.4.0-RC1"]
                 [slingshot "0.10.3"]
                 [clj-http "0.9.0"]
                 [org.clojure/data.json "0.2.4"]
                 [org.clojure/clojurescript "0.0-1450"]
                 [hiccup "1.0.5"]])
#+end_src

In this project, named "couchdb-from-clojure",
serveral libraries are used and listed as dependencies, for example
=clj-http= version 0.9.0 is used.
Once the project file is written, running =lein deps= in the project
directory causes Leiningen to fetch and configure the libraries listed.
Be warned that any currently running REPLs in the project will need
restarted before they see newly fetched libraries on the classpath.

The main impact of Leiningen on the software development process is
that is speeds and eases changes to library versions and selection;
this should be a benefit for Agile development.

** Downsides to using Clojure
Their are three major downsides to using Clojure for web development.

The first major downside is the relatively young age of Clojure as a langauge.
Many of the libraries and frameworks are still in alpha or beta, and in some cases
documentation is scarce or incomplete.
Code also happens to become obsolete rapidly; though continuous integration testing will
eliminate that issue as bugs due to API changes can be dealt with immediately as they arise.
Some Clojure libraries do not currently integrate with ClojureScript, and ClojureScript is not
currently self-supporting, since it uses the Google Closure compiler.
These issues should be fixed over time.

The second major downside is that Clojure runs on the Java Virtual Machine.
While this greatly extends the reach of Clojure and provides it with a vast array of well-tested libraries,
it also brings with it the requisite classpath issues.
Different JVMs will also affect code performance; for example, the icedtea-jdk running on the author's
GNU/Linux box sometimes experiences "out-of-memory" bugs and substantial delays even though ample memory is available.
However, most companies will likely have someone able to deal with Java problems and programmers with Java experience
are fairly easy to find.

The third major downside of using Clojure is the relative scarcity of Clojure programmers compared to other more traditional languages.
The result of this is that Clojure developers will be harder to hire and will need a higher salary;
on the other hand, since Clojure is not widely taught in universities, programmers using Clojure are more likely to be
personally motivated.
In addition, Clojure programmers will likely have better mathematical understanding due to functional programmings' mathematical roots,
and should be able to code faster using features such as the REPL and higher-order functions.

* Libraries for Web Development
** Clutch for NoSQL Database Interaction
Clutch is a library for interacting with Apache CouchDB in Clojure \cite{Clutch}.
It allows for high-level interaction with couchdb and there is experimental development with
modeling couchdb as an object that can support common Clojure higher-order functions like =seq= and =reduce=.
Be warned though, the API is still young and subject to change.
As the libraries README.md on Github states: At the moment, you'll have
to look at the source or introspect the docs once you've loaded Clutch
up to get around the API. Proper API documentation (via autodoc or
marginalia) coming soon."

Another option for interacting with couchdb is clj-http.
Clj-http is a lower-level library for interacting via http.
It is much more mature then Clutch.
Because CouchDB is RESTful and uses http in lieu of SQL the full functionality of
CouchDB is available using clj-http.

The map and reduce functions used in CouchDB views are typically written in JavaScript.
There is a Clojure View Server that comes with Clutch that allows map and reduce functions to
be written in Clojure.
The downside to this approach is that prominent hosted DBaaS providers such as CloudAnt do not have
the Clojure View Server installed, so using a the Clojure View Server creates an additional IT burden.

However, ClojureScript compiles to JavaScript, so the map and reduce functions can be written in ClojureScript,
then compiled before being written to the view document.
Unfortunately, this method does not allow for easy interaction with CouchDB as current compile times are lengthy (above five seconds).
Using the Futon utility that comes with CouchDB and developing views natively using JavaScript in a temporary view remains
a more convincing option at the time of this writing.

** Compojure for HTTP Routing
Compojure is a routing library that can be used to easily modularize a web page using Clojure.
Compojure is built on top of the Ring web server.
To start with Compojure, use lein to create a new project: =lein new compojure hello-world=.
This uses the =compojure= template to create a =project.clj= with all the necessary dependencies for
using Compojure.
Then =cd ./hello-world= and run =lein ring server-headless=. This commands Leiningen to start the Ring web server in
headless mode. Leiningen will report what port Ring is running on; typically Ring runs on port 3000 unless it is already taken.

A typical Compojure setup will have two namespaces: one in =routes.clj= and
one in =views.clj=
Examine the following =routes.clj= file, adapted from an example project from the Compojure project \cite{compojure-sample}.
#+begin_src clojure
(ns compojure.example.routes
  (:use compojure.core
        compojure.example.views
        [hiccup.middleware :only (wrap-base-url)])
  (:require [compojure.route :as route]
            [compojure.handler :as handler]
            [compojure.response :as response]))

(defroutes main-routes
  (GET "/hello/:id" [id foo] (index-page id foo))
  (route/resources "/")
  (route/not-found "Page not found"))

(def app
  (-> (handler/site main-routes)
      (wrap-base-url)))
#+end_src

The first s-expression (everything in the =(ns ...)=) declares the namespace
and loads requisite libraries. The second s-expression =(defroutes ...)= defines the
routes that are defined for http request.
For example, =(GET "/hello/:id" [id foo :as r] (index-page id foo r))= means that any
HTTP GET asking for anything in the /hello/ route takes the request and returns the result of
the index-page function. For example, and HTTP GET on http://localhost:3000/hello/%20try?foo=bar
will return the result of =(index-page " try" "bar")=.
This is defined in =views.clj=:

#+begin_src clojure
(ns compojure.example.views
  (:use [hiccup core page]))

(defn index-page [id foo]
  (html5
    [:head
      [:title "Hello World"]
      (include-css "/css/style.css")]
    [:body
     [:h1 "Hello World " id " " foo]]))
#+end_src

Here =index-page= is defined as a function with two parameters, =id= and =foo=.
An HTML string is returned using the =html5= macro, which is part of the Hiccup library
detailed in the next section.

The impact of the Compojure library on the software development process is that it serves as an interace between an
HTTP API and functions inside of code. Combined with a REPL-enabled editor like Emacs with CIDER, it enables very rapid
prototyping, testing, and debugging of the web application. It also provides a very compact high-level dispatch for HTTP requests.
Although not covered in the scope of this paper, there is a destructuring syntax that is part of Clojure that provides for a very
intuitive and terse parsing of requests.


** Hiccup for HTML Generation
Hiccup is a domain-specific langauge for creating HTML from Clojure data structures.
It contains the =html= macro that takes a specifically-formatted vector and generates
a string of HTML corresponding to that data.

For example, imagine that you are building an e-commerce application that sells fruit,
and you have a map of fruit prices: ={"apple" 0.50 "banana" 0.75}=.
The following code uses =map= to create a list of table-row vectors
i.e. =([:tr [:td "banana"] [:td 0.75]] [:tr [:td "apple"] [:td 0.5]])=
When =html= is used on this list it automatically expands the sequence to generate valid html.
The =spit= function outputs the resulting html string to "table.html".
#+begin_src clojure
  (spit "table.html"
        (html [:html [:table (map #(vector :tr
                                           [:td (first %)]
                                           [:td (second %)])
                                  {"apple" 0.50 "banana" 0.75})]]))
#+end_src

Table.html:
#+begin_src file
<html><table>
<tr><td>banana</td><td>0.75</td></tr>
<tr><td>apple</td><td>0.5</td></tr>
</table></html>
#+end_src
(Linebreaks have been added to the output file for readability).

Forms and form elements are also supported.

If one wished to dynamically generate all the web content for a site hiccup would certainly ease
the process. Of course, one must take into account server load and related issues that come with dynamically-generated
content. It should also be noted that dynamically generating all content may lead to maintenance issues;
as well as require UI and web designers to read code.
However, using the Compojure library to decompose requests can greatly ease the maintenance problem.
Template files can also still be used, with generated code inserted inside programatically.

** ClojureScript for Client-Side Scripting
lein trampoline cljsbuild repl-rhino

* Deploying Clojure
** Heroku

* Conclusion


* Appendix 1
** Extended Database Example
In the following example a Couch database is made and populated,
a view is written to query the database, and the view is then used
to generate an html file with the database contents in an html table.
Inspiratation for this example was found in the Couchdb Guide on view. \cite{CouchDB}
#+begin_src clojure
;; Define database name
(def fruitdb "http://localhost:5984/fruit")

;; Create the database
(clutch/create-database fruitdb)

;; Populate the database with some prices
(clutch/with-db fruitdb
        (clutch/bulk-update
         [{:fruit "apple"
           :price 0.50}
          {:fruit "banana"
           :price 0.75}
          {:fruit "grapes"
           :price 1.20}
          {:fruit "watermelon"
           :price 1.00}
          ]))

;; Define a view to get fruits and price
(clutch/with-db fruitdb
  (clutch/save-view
   "fruit-doc"
   (clutch/view-server-fns :cljs
                           {:view1
                            {:map (fn [doc]
                                    (js/emit (aget doc "fruit") (aget doc "price")))}})))

;; Query the view and parse into html
(spit "table.html"
      (let [price-map
            (reduce #(assoc %1 (:key %2) (:value %2)) {}
                    (clutch/get-view fruitdb "fruit-doc" "view1"))]
        (html [:html [:table (map #(vector :tr
                                           [:td (first %)]
                                           [:td (second %)])
                                  price-map)]])))
#+end_src

\begin{thebibliography}{99}
\bibitem[Clojure, 2014]{Clojure:2014}
http://clojure.org

\bibitem[Granger, 2014]{Granger}
http://www.chris-granger.com/2012/02/26/connecting-to-your-creation/

\bibitem[Bret Victor,2012]{Victor}
CUSEC 2012. Accessed at http://vimeo.com/36579366

\bibitem[Clutch, 2014]{Clutch}
https://github.com/clojure-clutch/clutch\

\bibitem[IBM, 2014]{IBM}
http://www.ibm.com/developerworks/library/j-couchdb-clojure/index.html#toggle

\bibitem[CouchDB,2014]{CouchDB}
http://guide.couchdb.org/draft/tour.html

\bibitem[Leiningen,2014]{lein}
https://github.com/technomancy/leiningen

\bibitem[Compojure,2014]{compojure-sample}
https://github.com/weavejester/compojure-example


\end{thebibliography}
